Welcome to CodaLab Worksheets!  This tutorial shows you how to use CodaLab Worksheets to run experiments and explains the basic CodaLab concepts.  Running experiments in CodaLab is quite simple but does require a slight shift in thinking (not unlike switching from a procedural language to a functional language).

CodaLab's philosophy is to give you full control of how you want to run your experiments and get out of your way.  It just maintains the dependency structure of your experiments and takes care of the actual execution.  A good analogy is Git, which gives you total freedom in terms of what to put in your repository, but just maintains the revision history.

One interacts with CodaLab mainly through a set of CodaLab commands for uploading, deleting, adding, running, etc.  These commands are to be typed either into the web terminal (at the top of the website where it says `CodaLab>`) or into the [command-line interface (CLI)](User_Install CodaLab CLI), if you prefer working from your shell.

Once you sign up for a CodaLab account and sign in, click on `My Home`.  Let's get started!

## Filesystem analogy

To understand CodaLab, it's useful to keep the following analogy in mind:

- shell = CodaLab session
- drive = CodaLab instance (e.g., `http://codalab.org/bundleservice`)
- directory = CodaLab worksheet (e.g., `home-pliang`)
- file = CodaLab bundle (e.g., `stanford-corenlp`)
- line in a file = CodaLab target (e.g., `stanford-corenlp/src`)

There are some differences, however:

- The contents of bundles are immutable (only the metadata is mutable), whereas
  files on a filesystem are mutable.
- A worksheet contains bundles in a user-specified order interleaved with text,
  whereas a directory in a file system contains an unordered set of files.
- CodaLab maintains the provenance information for each bundle.

## Basic Local Usage


Print out the list of available commands:

    cl help

Print out options for a specific command (e.g., upload):

    cl upload -h

If you're on the CLI, you need to connect to a CodaLab instance.

    cl work main::   # Connects to the main CodaLab server
    cl work local::  # Connects to the local instance (temporary)

Let's walk through a simple example to demonstrate the capabilities of
CodaLab.  The goal is to sort a file.

### Uploading bundles

To use CodaLab, you first need to create bundles.  You can do this by uploading
a bundle from your filesystem into a CodaLab instance.

Create a file called `a.txt` with the following contents:

    foo
    bar
    baz

Let's upload this dataset into CodaLab.  If you're in the web terminal, simply click on `Upload Bundle` to popup a dialog box to select the desired file (if you want to upload a directory, you need to zip it up).  If you're on the CLI, simply type:

    cl upload a.txt

A 32-character UUID will be printed.  This UUID uniquely identifies the Bundle.  Forever.  You can't edit the contents since bundles are immutable, but you can edit the metadata:

    cl edit a.txt

To list the bundles (one so far) you've uploaded, type:

    cl ls

You can see the statistics about the bundle:

    cl info -v a.txt

Let's now create and upload the following sorting program `sort.py`:

    import sys
    for line in sorted(sys.stdin.readlines()):
        print line,

like this:

    cl upload sort.py

Note that while `a.txt` and `sort.py` are dataset and programs, respectively,
from CodaLab's perspective, these are just bundles.  Bundles can also be
directories.

### Creating runs

One can upload bundles, but the interesting part about CodaLab is that new
bundles can be generated by running commands.  A *run* bundle consists of a set
of dependencies on existing bundles and an arbitrary *command* to execute.
When CodaLab runs this command behind the scenes, it makes sure the
dependencies are put into the right place.

Let us create our first run bundle:

    cl run sort.py:sort.py input:a.txt 'python sort.py < input > output' -n sort-run

The first two arguments specify the dependencies and the third is the command.
Each dependency has the form `<key>:<target>`; think of it as creating a
symlink called `<key>` pointing to `<target>`.  The target can be a bundle (e.g., `a.txt`),
or if the bundle is a directory rather than a file, we can references files
inside (e.g., `a.txt/file1`). During the run, targets are read-only.

Note that `cl run` doesn't actually run anything directly; it just creates the run
bundle and returns immediately.  You can see by doing `cl ls` that it's been
created, but it's state is `created`, not `ready`.  (On the CLI, you can add `-t` or
`--tail` to make `cl run` block and print out stdout/stderr, more like how you
would normally run a program.)

The `-n` (`--name`) can be used to set the name of a bundle (which doesn't have
to be unique).  Names must only contain alphanumeric characters (think of them
as variable names).

Look inside the bundle:

    cl info sort-run

You'll see that like any bundle, it consists of a set of files and directories.
Under *dependencies*, you will see two files (*keys*), `sort.py` and `input`,
which point to the *targets* `sort.py` and `a.txt`.

Note that runs need not have dependencies.  Here's a trivial run bundle that
doesn't:

    cl run 'echo hello'

In our original shell, we can check that
the run completed successfully.

    cl info -v sort-run

We can look at individual targets inside the bundle:

    cl cat sort-run/output

To make things more convenient, we can define a bundle that points to a target
inside the last bundle:

    cl make sort-run/output -n a-sorted.txt
    cl cat a-sorted.txt

On the CLI, we can also download the results to local disk:

    cl download a-sorted.txt

If you messed up somewhere, you can always remove a bundle:

    cl rm sort-run

You'll see that the above command threw an error, because `a-sorted.txt`
depends on `sort-run`.  To delete both bundles, you can remove recursively:

    cl rm -r sort-run

Note: be *very careful* with `rm -r` because it might delete a lot of bundles!

#### Sugar

You can also include bundle references directly in your run command, which
might be more natural than listing the dependencies ahead of time:

    cl run 'python %sort.py% < %a.txt% > output' -n sort-run
    cl run 'python %arg1:sort.py% < %arg2:a.txt% > output' -n sort-run
    cl run 'python %:sort.py% < %:a.txt% > output' -n sort-run

These are equivalent to the following, respectively:

    cl run b1:sort.py b2:a.txt 'python b1 < b2 > output' -n sort-run
    cl run arg1:sort.py arg2:a.txt 'python arg1 < arg2 > output' -n sort-run
    cl run sort.py:sort.py a.txt:a.txt 'python sort.py < a.txt > output' -n sort-run

Note that the last line is also equivalent to:

    cl run :sort.py :a.txt 'python sort.py < a.txt > output' -n sort-run

### Macros

Once we produce a run, we might want to do it again with slightly different
settings (e.g., sort another example).  CodaLab macros allow you to do this,
although understanding this concept requires us to take a step back.

In CodaLab, bundles form a directed acyclic graph (DAG), where nodes are
bundles and a directed edge from A to B means that B depends on A.  Imagine we
have created some runs that produces some output bundle O from some input
bundle I; I is an ancestor of O in the DAG.  Now suppose we have a new input
bundle I', how can we produce the analogous O'.  The *mimic* command does
exactly this.

First, recall that we have created `a.txt` (I) and `sort-run` (O).  Let us
create another bundle called `b.txt`:

    6
    3
    8

and upload it:

    cl upload b.txt

Now we can apply the same thing to `b.txt` that we did to `a.txt`:

    cl mimic a.txt a-sorted.txt b.txt -n b-sorted.txt

We can check that `b.txt.sorted` contains the desired sorted result:

    cl cat b-sorted.txt

Normally, in a programming language, we define macros as abstractions.  In
CodaLab though, notice that we've started instead by creating a concrete
example, and then used an analogy to re-apply this.  A positive side-effect is
that every macro automatically comes with an example of how it is used!

We can make the notion of a macro even more explicit.  Let's rename `a.txt` to
`sort-in1` and `a-sorted.txt` to `sort-out`:

    cl edit a.txt -n sort-in1
    cl edit a-sorted.txt -n sort-out

Then we can use the following syntactic sugar:

    cl macro sort b.txt -n b-sorted.txt

In CodaLab, macros are not defined ahead of time, but are constructed on the
fly from the bundle DAG.

### Worksheet basics

So far, we've focused on creating (and deleting) new bundles, and these bundles
automatically added to the current worksheet (`codalab`):

    cl work

In this way, a worksheet is like a directory.  But unlike a directory, it
remembers the order of the items (which can be changed) and a worksheet can
contain other items besides bundles.

We can add items (text or bundles) to the current worksheet, which appends to
the end:

    cl add text "Here's a simple bundle:"
    cl add bundle sort.py

A worksheet just contains pointers to bundles, and unlike bundles, they are
mutable.  We can display the contents of a worksheet as follows:

    cl print    # Shows all items (bundles, text, and worksheets)
    cl ls       # Only shows the bundles

We can create another worksheet:

    cl new scratch

This creates a new worksheet called `scratch`.  We can switch back and forth
between worksheets (analogous to switching directories using `cd`):

    cl work scratch
    cl work codalab

At this point, it is important to note that a worksheet only contains
*pointers* to bundles and other worksheets.  Their existence is independent of
the container worksheet (think symlinks or hyperlinks), although CodaLab keeps
track of the reverse to avoid broken links.

With this in mind, we can edit the contents of this worksheet in a text editor.

    cl wedit

On the CLI, in the popped up editor (determined by the `EDITOR` environment variable),
you'll see markdown interleaved with bundles, worksheets, and formatting directives.
See documentation of the [markdown syntax](https://github.com/codalab/codalab/wiki/User_Worksheet-Markdown).
For example, the editor might look like this:

    // Editing worksheet codalab(0x4734384f503944dfb15c23d7e466007a).
    Arbitrary text describing a bundle.
    [run run-echo-hello : echo hello]{0xa113e342f21347e4a65d1be833c3aaa8}
    Arbitrary text describing a worksheet.
    [worksheet scratch]{{0xfdd5d68b64c9450da918b24ce7708f34}}

You can leverage the full power of the editor to change the list of worksheet
items: you can add and remove text, bundles, worksheets.  You can switch the
order.  You can list a bundle multiple times.  You can do edit another
worksheet (e.g., `cl wedit scratch`) and transfer contents between the two.
This all works because the worksheet contents are merely pointers.  When you
remove a bundle or worksheet item, the item still exist; only the references to
them are removed.  At the end, you can display the fruits of your labor in the CLI:

    cl print

In the web interface, you can view and edit the worksheet.

To remove the worksheet, you need to first remove all the items by opening a
text editor and deleting all its contents and then running:

    cl wrm scratch

### Referencing bundles

So far, we have referred to bundles by their names.  In
a large CodaLab system with many users, names are not unique, and possibly not
even within the same worksheet.  A *bundle_spec* refers to the string that
identifies a bundle, importantly given the context (address, current
worksheet).

There are a number of ways to reference bundles:

- UUID (`0x3739691aef9f4b07932dc68f7db82de2`): this should match at most one
  bundle.  You can use a prefix (an error is thrown if the prefix doesn't
  resolve uniquely).
- Name (`foo`): matches the *last* bundle on the current worksheet with the
  given name.  You can use `foo%` to match bundles that begin with `foo` or
  `%foo%` to match bundles that contain `foo` (SQL LIKE syntax).
  You can use `w1/foo` to refer to a bundle by name on worksheet `w1`.
- Ordering (`^, ^2, ^3`): returns the first, second, and third bundles from the end
  of the current worksheet.
- Named ordering (`foo^, foo^2, foo^3`): returns the first, second, and third
  bundles from the end with the given name.
- You can refer to a range of bundles: `^1-3` resolves to `^1 ^2 ^3`.

In practice, `^` and `^2` are used frequently because future operations tend to
depend on the bundles you just created.

Warning: ordering references are not stable.  For example,
if you run:

    cl ls
    cl rm ^1
    cl rm ^2

This *does not* delete the first and second last bundles, but rather the first
and third!  The intended behavior is:

    cl rm ^1 ^2

Also, if someone else is adding to your worksheet while you're editing it, you
might end up referring to the wrong bundle.

### Executing commands

On the CLI, when editing a worksheet, you can specify commands to execute right
in the worksheet.  For example, if you add `!rm ^`` after a bundle:

    [run run-echo-hello : echo hello]{0xa113e342f21347e4a65d1be833c3aaa8}
    !rm ^

Then when you save the worksheet, then it is as if the following command was executed:

    cl rm 0xa113e342f21347e4a65d1be833c3aaa8

One common use case of these embedded commands is to move bundles around and
mark some as ones to `rm` or `kill`.

In the general case, after a worksheet has been processed, every line of the
form `!<command>` is converted into `cl <subst-command>`, where
`<subst-command>` is `<command>` where `^` is replaced with the bundle
immediately preceding the command.

## Working remotely

So far, we have been doing everything locally, but one advantage of CodaLab is
to have a centralized instance so that both the data and the computational
resources can be shared and scaled.

### Connecting to an existing server

Usually, a CodaLab instance will already be set up and you can just connect to
it directly.  For example, suppose a CodaLab instance is running at
`http://example.com:2800`.  Then you can connect to it by typing:

    cl work http://example.com:2800::<username>

This sets your current worksheet to `<username>` (think directory in the filesystem
analogy) on the remote machine (think drive).  The general form is:

    cl work <address>::<worksheet>
    cl work <address>::             # Defaults to <worksheet>=<username>

It is convenient to create an alias so you don't have to type the address every time:

    cl alias ex http://example.com:2800

so you now just need to type:

    cl work ex::

This will prompt you for your username and password.

### Copying between instances

It is easy to copy bundles and other worksheet items between instances.
To illustrate this concept, let us create a separate CodaLab instance:

    export CODALAB_HOME=~/.codalab2
    cl ls

You should see that there's nothing there because we are now accessing the new
CodaLab instance backed by `~/.codalab2` rather than `~/.codalab`.  In this shell,
the situation is as follows:

    local => ~/.codalab2
    localhost => ~/.codalab

We can copy bundles between CodaLab instances by doing:

    cl add bundle localhost::a.txt local::

Now there are two physical copies of the bundle `a.txt`, and they have the same
bundle UUID.  We can create a bundle and copy it in the other direction too:

    echo hello > hello.txt
    cl upload hello.txt
    cl add bundle hello.txt localhost::

By default, `cl add bundle` does not copy the dependencies of a bundle.  If you want to
copy the dependencies (for example, to reproduce a run on another machine),
then use `cl add bundle -d`.  The dependencies of the dependencies are not copied,
since only the immediate dependencies are required to execute a run.

In general, the `add bundle` command is as follows:

    cl add bundle [<address>::]<bundle> [<address>::]<worksheet>

To copy all the items from a worksheet (except worksheet items) to another:
    
    cl wadd [<address>::]<worksheet> [<address>::]<worksheet>

Note that worksheets themselves are not copied, just the items within a
worksheet.  Any bundles that don't exist on the destination CodaLab instance
are copied over.

### Permissions

CodaLab implements the following permissions model:

- Users belong to groups.
- Each group has access to some bundles and worksheets.

There are three levels of access or permission:

- `none`: You can't even see that the worksheet exists.
- `read`: You can read/download, but not edit.
- `all`: You can do anything (edit/delete/etc.).

Notes:

- There is a designated `public` group to which all users implicitly belong.  If
  you want to make a worksheet world-readable, give the `public` group read
  permission.
- There is a designated root user (`codalab`) that has `all` permission to
  all bundles and worksheets.
- Each user has `all` permission to all bundles and worksheets that he/she owns.

To grant/revoke permissions:

    cl perm <bundle> <group> <(n)one|(r)ead|(a)ll>
    cl wperm <bundle> <group> <(n)one|(r)ead|(a)ll>

For example:

    cl perm bundle1 public r  # grant read permission
    cl perm bundle1 public a  # grant all permission
    cl perm bundle1 public n  # revoke permissions

We can transfer ownership (and therefore permissions) of bundles and
worksheets:

    cl chown <username> <bundle-1> ... <bundle-n>
    cl wedit <worksheet> -o <username>

To make a worksheet `w1` mutually-writable with your research group, first
create a group `g1`, add users `u1` and `u2` to it, and then give the group all
access:

    cl gnew g1
    cl uadd u1 g1
    cl uadd u2 g1
    cl wperm w1 g1 all

All bundles created on `w1` will initially inherit the permissions of that
worksheet, but these permissions can be changed independently.
    
To list the groups that you've created or belong to:

    cl gls

To look more into a given group `g1`:

    cl ginfo g1

## Search

The `cl search` command allows us to find bundles and compute various
statistics over them.  The search performs a conjunction over keywords.

    cl search <keyword-1> ... <keyword-n>

Some initial examples:

    cl search mnist                        # bundles whose name or uuid contains `mnist`
    cl search e342f                        # bundles whose name or uuid contains `e342f`
    cl search type=program                 # program bundles
    cl search name=mnist                   # bundles whose names is exactly `mnist`
    cl search state=running                # all running bundles
    cl search command=%python%             # bundles whose command contains `python`
    cl search dependency=0xa11%            # bundles that depends on the given bundle
    cl search worksheet=0xfdd%             # bundles that are on the given worksheet
    cl search owner=codalab                # bundles that are owned by the given user name
    cl search =%python%                    # match any field

You can combine search terms:

    cl search type=program owner=codalab   # programs owned by user `codalab`

You can change the number and ordering of results:

    cl search .offset=50 .limit=100        # bundles 50-99
    cl search size=.sort                   # sort by increasing size
    cl search size=.sort-                  # sort by decreasing size

There are some special commands:

    cl search .mine                        # show bundles that the current user owns
    cl search .last                        # bundles in reverse order of creation
    cl search .floating                    # bundles that aren't on any worksheet

Operations that return a single number rather than a list of bundles:

    cl search .count                       # return total number of bundles in the system
    cl search size=.sum                    # return total number of bytes (nominal)
    cl search size=.sum data_hash=0x%      # return total number of bytes (actual, where we only count bundles with data)

We can combine these keywords to yield the following handy queries:

    cl search .mine .last                  # bundles that you just created
    cl search .mine .floating              # bundles that are floating (probably want to delete these periodically)
    cl search .mine size=.sort-            # what are the biggest bundles I own?

The search returns a list of bundles.  We can use `-u` to just get the uuids.
This can be piped into other commands:

    cl search .mine .floating -u | xargs cl rm  # delete the floating bundles
    cl search mnist -u | xargs cl add           # add mnist to the current worksheet

We can list and search worksheets in a similar fashion:

    cl wls                       # all worksheets
    cl wls .mine                 # my worksheet
    cl wls .last .limit=3        # last worksheets created
    cl wls name=.sort            # worksheets sorted by name
    cl wls bundle=0x3bb%         # worksheets containing this bundle
    cl wls owner=codalab         # worksheets owned by `codalab`
    cl wls =%Hello%              # worksheets containing 'Hello'

## Updating CodaLab

To update to the newest version of CodaLab, run:

    git pull

When you do this, the database schema might have changed, and you need to
perform a *database migration*.  To be on the safe side, first backup your
database.  Then run:

    venv/bin/alembic upgrade head

# User tips

The following describes some common tip and tricks to make the most out of CodaLab.

Delete the last five bundles (remember this also removes all other instances of
these bundles on the current worksheet):

    cl rm ^1-5

To kill the last bundle:

    cl kill ^

Most CodaLab commands generate one or more bundle UUIDs.  These can be piped to
further commands.  To kill all running bundles (be careful!):

    cl search state=running -u | xargs cl kill

To delete all *floating* bundles that do not appear on a worksheet (be careful!):

    cl search .floating -u | xargs cl rm

To run a bundle and create another bundle that depends on it:

    cl make $(cl run date)/stdout -n stdout

To wait for the last bundle to finish and then print out its output:
    
    cl run 'sleep 10; date'
    cl cat $(cl wait ^)/stdout

To find out what happened to the last bundle (e.g., why it failed):

    cl info -v ^

To rerun the last bundle (`-f args` prints out the command that was used to
generate the bundle):

    cl info -f args ^ | xargs cl

To put the command of a bundle back on the command-line for editing, create
this handy alias in bash:

    clhist() {
      history -s cl $(cl info -f args $1)
    }

Dependent bundles are read-only during a run, so to change files or
add to a dependent directory, everything must first be copied. Example
of compiling a source tree as a run bundle:

    cl run :src 'cp -r src src-build && cd src-build && make'

To compare two worksheets:

    vimdiff <(cl print -r worksheet1) <(cl print -r worksheet2)

To replace the contents of worksheet2 with worksheet1 (be careful when we do
this, since all the contents of worksheet1 are removed, although the bundles
themselves are not removed and will be floating):

    cl wedit -f /dev/null -w worksheet2
    cl wadd worksheet1 worksheet2

To change the metadata of a worksheet (e.g., rename or change the owner):

    cl wedit <worksheet> -n <new name>
    cl wedit <worksheet> -o <new owner>

To change the metadata of a bundle (e.g., rename or change the description):

    cl edit <bundle> -n <new name>
    cl edit <bundle> -d <new description>

## Editing worksheets

By default, you will use `cl wedit` to edit worksheets.  However, it is
convenient to just keep a text editor open.  Here's one way to do this.

1. Save the contents of a worksheet to a local file:

        cl print -r codalab > codalab.ws

2. Edit `codalab.ws`.

3. Save the worksheet back into CodaLab:

        cl wedit codalab -f codalab.ws

It is useful to define editor macros to execute the first and third commands.
For example, in vim, you could define a *save* and *load* command by adding the
following two lines to your `.vimrc`:

    map mk :wa<CR>:!cl wedit % -f %<CR>
    map mr :wa<CR>:!cl print -r % > %<CR>

The file that you load is in general not identical to the one you save (because
references get interpreted and commands get executed), so it's a good idea to
load right after you save.

Also, if you add bundles to the worksheet on the CLI, then you should reload
the worksheet before you make edits or else you will lose those changes.

## Where things are stored

For reference, your CodaLab settings here:

    ~/.codalab/config.json

The session state and authentication tokens are stored here:

    ~/.codalab/state.json

By default, the metadata is stored in a SQLite database (you should switch to a
real database such as MySQL if you're going to do anything serious):

    ~/.codalab/bundle.db

All the bundles corresonding to the `local` address are stored here:

    ~/.codalab/data